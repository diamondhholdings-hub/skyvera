---
phase: 01-foundation-and-data-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/semantic/schema/financial.ts
  - src/lib/semantic/schema/customer.ts
  - src/lib/semantic/schema/index.ts
  - src/lib/semantic/resolver.ts
  - src/lib/semantic/validator.ts
  - src/lib/cache/manager.ts
autonomous: true

must_haves:
  truths:
    - "Calling resolveMetric('ARR', { bu: 'Cloudsense' }) returns the same number every time regardless of which feature calls it"
    - "getMetricDefinition('ARR') returns a human-readable definition string usable by Claude for prompt enrichment"
    - "Validating a real customer record from data/customers_cloudsense_all.json passes without errors"
    - "Validating a malformed record (null rr, missing customer_name) returns a Result with success=false and descriptive error"
    - "Cache returns stored value before TTL expiry and fetches fresh data after TTL expiry"
    - "Cache gracefully degrades if storage fails (returns fetched data without caching)"
  artifacts:
    - path: "src/lib/semantic/resolver.ts"
      provides: "Single source of truth for all metric calculations"
      exports: ["SemanticResolver"]
      min_lines: 80
    - path: "src/lib/semantic/validator.ts"
      provides: "Data validation at all boundaries"
      exports: ["DataValidator"]
      min_lines: 50
    - path: "src/lib/cache/manager.ts"
      provides: "Cache-aside pattern with TTL and jitter"
      exports: ["CacheManager"]
      min_lines: 60
    - path: "src/lib/semantic/schema/financial.ts"
      provides: "Metric definitions with natural language descriptions"
      exports: ["METRIC_DEFINITIONS"]
  key_links:
    - from: "src/lib/semantic/resolver.ts"
      to: "src/lib/cache/manager.ts"
      via: "cache.get() calls for all metric lookups"
      pattern: "cache\\.get"
    - from: "src/lib/semantic/resolver.ts"
      to: "src/lib/semantic/schema/financial.ts"
      via: "imports metric definitions for calculation logic"
      pattern: "METRIC_DEFINITIONS"
    - from: "src/lib/semantic/validator.ts"
      to: "src/lib/types/customer.ts"
      via: "uses Zod schemas for validation"
      pattern: "CustomerSchema\\.safeParse"
---

<objective>
Build the semantic layer (metric definitions, resolver, validator) and cache manager that serve as the single source of truth for all business metrics and data access.

Purpose: Research shows the semantic layer must exist BEFORE any features. Without it, ARR gets calculated differently in the dashboard vs. scenario modeler vs. NL query handler. The cache manager enables 15-minute TTL caching that prevents API rate limits and provides sub-second responses. Together, these are the two most critical foundational components.

Output: SemanticResolver that resolves any metric by name with caching, DataValidator that validates all external data with Zod, CacheManager with TTL and jitter, and metric definitions usable by both code and Claude prompts.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-data-integration/01-RESEARCH.md

# Types defined in Plan 01 (will exist by execution time)
# Reference: src/lib/types/financial.ts, src/lib/types/customer.ts, src/lib/types/result.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build semantic layer with metric definitions, resolver, and validator</name>
  <files>
    src/lib/semantic/schema/financial.ts
    src/lib/semantic/schema/customer.ts
    src/lib/semantic/schema/index.ts
    src/lib/semantic/resolver.ts
    src/lib/semantic/validator.ts
  </files>
  <action>
    **src/lib/semantic/schema/financial.ts** -- Metric definitions as single source of truth. This is NOT a duplicate of the Zod schemas in types/financial.ts. This file defines BUSINESS MEANING and CALCULATION RULES for each metric:

    ```typescript
    export interface MetricDefinition {
      name: string
      displayName: string
      description: string              // Human-readable for Claude prompts
      formula: string                  // How it's calculated
      unit: 'currency' | 'percentage' | 'count' | 'ratio'
      source: string                   // Which data source (Excel sheet name)
      calculate: (data: Record<string, number>) => number  // Actual calculation function
    }
    ```

    Define METRIC_DEFINITIONS map for these metrics:
    - ARR: "Annual Recurring Revenue = Quarterly RR x 4. Source: Excel RR Summary sheet."
      - calculate: (data) => data.quarterlyRR * 4
    - EBITDA: "Earnings Before Interest, Taxes, Depreciation, Amortization. Source: Excel P&Ls sheet."
      - calculate: (data) => data.totalRevenue - data.cogs - data.opex
    - NetMargin: "Net Margin % = (Revenue - All Costs) / Revenue x 100. Source: Excel P&Ls sheet."
      - calculate: (data) => ((data.totalRevenue - data.totalCosts) / data.totalRevenue) * 100
    - GrossMargin: "Gross Margin % = (Revenue - COGS) / Revenue x 100."
      - calculate: (data) => ((data.totalRevenue - data.cogs) / data.totalRevenue) * 100
    - TotalRevenue: "Total Revenue = RR + NRR for a business unit."
      - calculate: (data) => data.rr + data.nrr
    - CustomerCount: "Number of active customers in a business unit."
      - calculate: (data) => data.customerCount
    - RRDecline: "Change in Recurring Revenue vs prior plan. Negative means contraction."
      - calculate: (data) => data.currentRR - data.priorRR

    Include `getMetricDefinition(name: string): string` that returns the human-readable description string for Claude prompt enrichment.

    Include `getAllMetricDefinitions(): string` that returns ALL definitions formatted for Claude system prompt injection.

    **src/lib/semantic/schema/customer.ts** -- Customer health scoring definitions:
    - Define health score calculation rules:
      - GREEN: RR stable or growing, no AR > 90 days, renewal confirmed
      - YELLOW: RR declining < 10%, some AR > 90 days, renewal uncertain
      - RED: RR declining > 10%, significant AR > 90 days, renewal at risk
    - Export `calculateHealthScore(customer: Customer): { score: 'green' | 'yellow' | 'red', factors: string[] }`

    **src/lib/semantic/schema/index.ts** -- Barrel file.

    **src/lib/semantic/resolver.ts** -- SemanticResolver class:
    - Constructor takes a CacheManager instance (dependency injection, not imported globally)
    - `resolveMetric(metricName: string, context: { bu?: string, quarter?: string }): Promise<Result<number>>` -- Resolves any metric by name. Checks cache first (key: `metric:${name}:${bu}:${quarter}`). Uses METRIC_DEFINITIONS to calculate. Returns Result type.
    - `resolveCustomerMetrics(customerName: string, bu: string): Promise<Result<CustomerFinancials>>` -- Returns all financial metrics for a customer. Wraps in cache.
    - `getMetricDefinitionsForPrompt(metricNames?: string[]): string` -- Returns metric definitions formatted for Claude prompt injection.
    - The resolver does NOT call adapters directly yet (adapters built in Plan 04). Instead, define a `DataProvider` interface: `{ getFinancialData(bu: string): Promise<Result<FinancialData>>, getCustomerData(bu: string): Promise<Result<Customer[]>> }`. The resolver uses this interface. Plan 04 will implement it.
    - For now, include a `MockDataProvider` that returns data from the existing JSON files (data/customers_*.json) loaded at startup. This enables testing the semantic layer immediately.

    **src/lib/semantic/validator.ts** -- DataValidator class:
    - `validateCustomer(data: unknown): Result<Customer, ValidationError>` -- Uses CustomerSchema.safeParse, wraps in Result type
    - `validateFinancial(data: unknown): Result<FinancialMetrics, ValidationError>` -- Uses FinancialMetricsSchema.safeParse
    - `validateBatch<T>(data: unknown[], schema: ZodSchema<T>): { valid: T[], invalid: Array<{ index: number, errors: string[] }> }` -- Batch validation with detailed error reporting per item
    - `reconcile(sources: Map<string, unknown>): Result<UnifiedData>` -- Merge data from multiple sources with source-of-truth rules (Excel is authoritative for financials)
    - Log validation failures with context (which field failed, what the value was)
  </action>
  <verify>
    `npx tsc --noEmit` passes. Import SemanticResolver and DataValidator. Verify:
    1. METRIC_DEFINITIONS has entries for ARR, EBITDA, NetMargin, GrossMargin, TotalRevenue, CustomerCount, RRDecline
    2. getMetricDefinition('ARR') returns a non-empty string containing "Annual Recurring Revenue"
    3. calculateHealthScore returns 'green', 'yellow', or 'red' with factors array
    4. DataValidator.validateCustomer with valid data returns { success: true }
    5. DataValidator.validateCustomer with { customer_name: null } returns { success: false }
  </verify>
  <done>Semantic layer provides single source of truth for all metric definitions and calculations. DataValidator validates all external data. SemanticResolver resolves metrics with caching via DataProvider interface.</done>
</task>

<task type="auto">
  <name>Task 2: Build cache manager with in-memory storage, TTL, jitter, and invalidation</name>
  <files>
    src/lib/cache/manager.ts
  </files>
  <action>
    **src/lib/cache/manager.ts** -- CacheManager class implementing cache-aside pattern:

    Use an in-memory Map for demo (research recommends this over Redis for single-instance demo). Abstract behind interface so Redis can be swapped post-demo.

    ```typescript
    interface CacheEntry<T> {
      value: T
      expiresAt: number  // Unix timestamp ms
      createdAt: number
    }

    interface CacheOptions {
      ttl: number          // Base TTL in seconds
      jitter?: boolean     // Add ±10% jitter to TTL (default true)
    }
    ```

    CacheManager methods:
    - `get<T>(key: string, fetcher: () => Promise<T>, options: CacheOptions): Promise<T>` -- Cache-aside: check cache, if miss call fetcher, store result, return. If cache read fails, log warning and fetch fresh (graceful degradation).
    - `set<T>(key: string, value: T, options: CacheOptions): void` -- Manual set with TTL.
    - `invalidate(key: string): boolean` -- Remove single key. Returns true if key existed.
    - `invalidatePattern(pattern: string): number` -- Remove all keys matching glob pattern (e.g., 'metric:ARR:*'). Use simple string matching (startsWith, includes). Returns count of removed keys.
    - `getWithMetadata<T>(key: string): { value: T, createdAt: Date, expiresAt: Date, ttlRemaining: number } | null` -- For "last updated X minutes ago" display.
    - `clear(): void` -- Clear all cache entries.
    - `stats(): { size: number, hitRate: number, missRate: number }` -- Track hit/miss for monitoring.

    Internal:
    - `addJitter(baseTTL: number): number` -- Add ±10% random jitter to prevent thundering herd.
    - Track hits/misses counter for stats().
    - Run periodic cleanup of expired entries (every 60 seconds via setInterval). Store interval reference for cleanup.
    - `dispose(): void` -- Clear interval and cache (for clean shutdown).

    Default TTL constants (exported):
    ```typescript
    export const CACHE_TTL = {
      FINANCIAL: 300,      // 5 minutes for financial data (changes quarterly)
      NEWS: 900,           // 15 minutes for news intelligence
      CLAUDE_RESPONSE: 300, // 5 minutes for Claude responses (user queries)
      CLAUDE_ENRICHMENT: 900, // 15 minutes for background enrichment
      CUSTOMER_DATA: 600,  // 10 minutes for customer records
    } as const
    ```

    Make CacheManager a singleton pattern (one instance per app). Export `getCacheManager(): CacheManager`.
  </action>
  <verify>
    `npx tsc --noEmit` passes. Write a quick test in a temporary file:
    1. Set value with 2-second TTL, get immediately -> returns value
    2. Wait 3 seconds, get same key -> calls fetcher (cache expired)
    3. invalidatePattern('metric:*') removes all metric keys
    4. stats() returns { size, hitRate, missRate } with correct counts
    5. Verify graceful degradation: even if set() throws (simulate), get() still returns fetcher result

    Delete the test file after verifying.
  </verify>
  <done>CacheManager provides cache-aside pattern with configurable TTL, jitter, pattern invalidation, metadata retrieval, and hit/miss stats. Used by SemanticResolver and Claude orchestrator. Gracefully degrades if cache operations fail.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with all semantic layer and cache code
2. SemanticResolver.resolveMetric('ARR', { bu: 'Cloudsense' }) returns a Result
3. DataValidator.validateCustomer validates real customer JSON data
4. CacheManager.get() returns cached value before TTL, fetches fresh after TTL
5. METRIC_DEFINITIONS contains all 7 core metrics with calculation functions
6. getMetricDefinitionsForPrompt() returns formatted string suitable for Claude system prompts
</verification>

<success_criteria>
- SemanticResolver exists with DataProvider interface for pluggable data sources
- All 7 core metric definitions (ARR, EBITDA, NetMargin, GrossMargin, TotalRevenue, CustomerCount, RRDecline) defined with calculation functions and human-readable descriptions
- DataValidator validates customers and financial data using Zod schemas with Result return types
- CacheManager provides cache-aside with TTL, jitter, pattern invalidation, and graceful degradation
- MockDataProvider loads existing JSON files for immediate testing
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-data-integration/01-02-SUMMARY.md`
</output>
