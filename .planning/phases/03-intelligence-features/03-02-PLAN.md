---
phase: 03-intelligence-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/intelligence/nlq/types.ts
  - src/lib/intelligence/nlq/canned-queries.ts
  - src/lib/intelligence/nlq/interpreter.ts
  - src/app/api/query/route.ts
  - src/app/query/page.tsx
  - src/app/query/loading.tsx
  - src/app/query/components/query-input.tsx
  - src/app/query/components/canned-queries.tsx
  - src/app/query/components/query-results.tsx
  - src/app/query/components/metrics-catalog.tsx
autonomous: true

must_haves:
  truths:
    - "User clicks a canned query from categorized list and sees answer with data points and sources"
    - "User types free-form question and receives interpreted answer or clarification dialog"
    - "Clarification dialog shows 2-3 options when query is ambiguous, user selects one to refine"
    - "User browses metrics catalog showing all available metrics with definitions, formulas, and sources"
    - "User sees suggested follow-up questions after receiving an answer"
    - "Loading state shows during query processing with appropriate messaging"
  artifacts:
    - path: "src/lib/intelligence/nlq/types.ts"
      provides: "Zod schemas for NLQ request/response and clarification types"
      contains: "nlqResponseSchema"
    - path: "src/lib/intelligence/nlq/canned-queries.ts"
      provides: "5-7 pre-programmed queries across 4 categories"
      exports: ["CANNED_QUERIES"]
    - path: "src/lib/intelligence/nlq/interpreter.ts"
      provides: "Claude-powered query interpretation with clarification support"
      exports: ["interpretQuery"]
    - path: "src/app/api/query/route.ts"
      provides: "POST endpoint for NLQ processing"
      exports: ["POST"]
    - path: "src/app/query/page.tsx"
      provides: "Server Component page with available data sources"
    - path: "src/app/query/components/query-input.tsx"
      provides: "Search bar with submit and clear"
      contains: "use client"
    - path: "src/app/query/components/canned-queries.tsx"
      provides: "Categorized canned query cards"
      contains: "use client"
    - path: "src/app/query/components/query-results.tsx"
      provides: "Answer display with data points, sources, and follow-ups"
      contains: "use client"
    - path: "src/app/query/components/metrics-catalog.tsx"
      provides: "Browseable metric definitions from semantic layer"
      contains: "use client"
  key_links:
    - from: "src/app/query/components/query-input.tsx"
      to: "/api/query"
      via: "fetch POST on form submit"
      pattern: "fetch.*api/query"
    - from: "src/app/api/query/route.ts"
      to: "src/lib/intelligence/nlq/interpreter.ts"
      via: "interpretQuery function call"
      pattern: "interpretQuery"
    - from: "src/lib/intelligence/nlq/interpreter.ts"
      to: "src/lib/intelligence/claude/orchestrator.ts"
      via: "getOrchestrator().processRequest()"
      pattern: "getOrchestrator"
    - from: "src/app/query/components/metrics-catalog.tsx"
      to: "src/lib/semantic/schema/financial.ts"
      via: "imports METRIC_DEFINITIONS directly"
      pattern: "METRIC_DEFINITIONS"
---

<objective>
Build natural language query interface: users select from canned query library or type free-form questions, receive Claude-interpreted answers with data points and sources, and browse a metrics catalog for available data definitions.

Purpose: Enables executives to ask business questions in plain English (e.g., "What is the ARR for each business unit?") without needing SQL or spreadsheet knowledge - with guided templates for common queries and free-form for edge cases.
Output: Working /query page with canned query library, free-form input, clarification dialog, answer display, and metrics catalog.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-intelligence-features/03-RESEARCH.md

Key existing files to reference:
@src/lib/intelligence/claude/orchestrator.ts - ClaudeOrchestrator singleton, processRequest()
@src/lib/intelligence/claude/prompts/nl-query.ts - buildNLQueryPrompt() with clarification support
@src/lib/semantic/schema/financial.ts - METRIC_DEFINITIONS, getMetricDefinition(), getAllMetricDefinitions()
@src/lib/data/server/dashboard-data.ts - getDashboardData(), getBUSummaries() for data context
@src/lib/data/server/account-data.ts - getAccountsWithHealth() for customer data context
@src/lib/types/result.ts - Result<T,E>, ok(), err()
</context>

<tasks>

<task type="auto">
  <name>Task 1: NLQ service layer (types, canned queries, interpreter) and API route</name>
  <files>
    src/lib/intelligence/nlq/types.ts
    src/lib/intelligence/nlq/canned-queries.ts
    src/lib/intelligence/nlq/interpreter.ts
    src/app/api/query/route.ts
  </files>
  <action>
    **1. Create `src/lib/intelligence/nlq/types.ts`:**
    - Define `CannedQuery` interface: { id: string, label: string, category: 'performance' | 'customers' | 'financials' | 'comparisons', template: string, requiredFilters?: Array<'bu' | 'quarter' | 'customer'> }
    - Define `QueryFilters` interface: { bu?: string, quarter?: string, customer?: string }
    - Define `nlqRequestSchema` (Zod): { query: z.string().min(3, 'Query too short').max(500, 'Query too long'), filters: optional object, conversationContext: optional string }
    - Define `NLQRequest = z.infer<typeof nlqRequestSchema>`
    - Define `nlqResponseSchema` (Zod) for Claude response validation:
      - interpretation: string
      - answer: string nullable
      - dataPoints: z.record(z.string(), z.union([z.number(), z.string()])).optional()
      - needsClarification: boolean
      - clarificationQuestion: string optional
      - clarificationOptions: string array optional
      - sources: string array
      - confidence: enum HIGH|MEDIUM|LOW
      - suggestedFollowUps: string array optional
    - Export `NLQResponse = z.infer<typeof nlqResponseSchema>`
    - Define `QueryResult` type: { query: string, response: NLQResponse, timestamp: Date }

    **2. Create `src/lib/intelligence/nlq/canned-queries.ts`:**
    - Export `CANNED_QUERIES: CannedQuery[]` array with 7 queries:
      1. id: 'arr-by-bu', label: 'What is the ARR for each business unit?', category: 'financials', template: 'Get Annual Recurring Revenue (ARR) breakdown by business unit for Q1\'26', requiredFilters: []
      2. id: 'margin-gap', label: 'Why are we missing our margin target?', category: 'performance', template: 'Analyze the margin gap between actual ({netMarginPct}%) and target ({netMarginTarget}%) for {bu} in Q1\'26, identifying top cost drivers', requiredFilters: ['bu']
      3. id: 'customer-churn-risk', label: 'Which customers are at risk of churning?', category: 'customers', template: 'Identify customers with red or yellow health scores, sorted by ARR impact', requiredFilters: []
      4. id: 'bu-comparison', label: 'Compare performance across business units', category: 'comparisons', template: 'Compare revenue, margin, and EBITDA across Cloudsense, Kandy, and STL for Q1\'26', requiredFilters: []
      5. id: 'vendor-costs', label: 'What are our largest vendor costs?', category: 'financials', template: 'List top vendor costs by business unit, focusing on contracts over $50K/quarter', requiredFilters: ['bu']
      6. id: 'rr-decline', label: 'Why is recurring revenue declining?', category: 'performance', template: 'Analyze the $336K RR decline vs prior plan, break down by business unit and identify root causes', requiredFilters: []
      7. id: 'ebitda-test', label: 'Why did we fail the EBITDA test?', category: 'performance', template: 'Explain why the FY\'25 EBITDA test failed, showing key contributing factors and the gap to target', requiredFilters: []
    - Export `getCannedQueryById(id: string): CannedQuery | undefined`
    - Export `getCannedQueriesByCategory(category: string): CannedQuery[]`
    - Export function `expandTemplate(template: string, filters: QueryFilters, metrics?: Record<string, number>): string` - replaces {bu}, {quarter}, {customer}, {netMarginPct}, {netMarginTarget} placeholders

    **3. Create `src/lib/intelligence/nlq/interpreter.ts`:**
    - Export async function `interpretQuery(query: string, conversationContext?: string): Promise<Result<NLQResponse>>`
    - Import `getOrchestrator` from `@/lib/intelligence/claude/orchestrator`
    - Import `buildNLQueryPrompt` from `@/lib/intelligence/claude/prompts/nl-query`
    - Import `getAllMetricDefinitions` from `@/lib/semantic/schema/financial`
    - Build available data sources list: ['P&L data for Cloudsense, Kandy, STL', 'Recurring Revenue (RR) by customer and BU', 'Non-Recurring Revenue (NRR) by BU', 'Customer health scores (140 customers)', 'Vendor costs and contracts', 'Headcount and salary data', 'Accounts Receivable aging data', 'Margin targets by BU']
    - Call buildNLQueryPrompt(query, dataSources, conversationContext)
    - Inject metric definitions as system prompt context using getAllMetricDefinitions()
    - Call `getOrchestrator().processRequest({ prompt, systemPrompt: metricDefs, priority: 'HIGH', maxTokens: 2048, temperature: 0.5 })`
    - Parse response.content as JSON, validate with `nlqResponseSchema.safeParse()`
    - If validation fails: return err() with descriptive message
    - If Claude unavailable: return ok() with mock response: { interpretation: query, answer: 'Claude AI is not configured. Please set ANTHROPIC_API_KEY.', needsClarification: false, sources: [], confidence: 'LOW', dataPoints: {} }
    - Return ok(validatedResponse)
    - Also export `interpretQueryWithData(query: string, contextData: Record<string, unknown>, conversationContext?: string): Promise<Result<NLQResponse>>` - same as above but prepends data context to prompt for data-enriched answers

    **4. Create `src/app/api/query/route.ts`:**
    - Export async POST handler
    - Parse request body with `nlqRequestSchema.safeParse()`
    - If validation fails: return 400 with Zod error messages
    - Determine if this is a canned query (check for `cannedQueryId` field in body)
    - If canned query: look up template, expand with filters, use as query
    - If free-form: use query directly
    - Call `interpretQuery(query, body.conversationContext)`
    - If response.needsClarification: return 200 with clarification data
    - If response has answer: return 200 with full response
    - All errors return appropriate HTTP status codes with error messages
    - Include response timestamp in return body
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root. All new files must compile without errors.
    Verify CANNED_QUERIES has exactly 7 entries across 4 categories.
    Verify the API route exports a POST function.
  </verify>
  <done>
    Service layer compiles: 7 canned queries defined across 4 categories with template expansion, interpreter calls Claude via orchestrator with metric definitions as context, validates response with Zod, API route accepts POST with query/filters and returns interpreted answer or clarification request.
  </done>
</task>

<task type="auto">
  <name>Task 2: NLQ UI page with query input, canned queries, results, and metrics catalog</name>
  <files>
    src/app/query/page.tsx
    src/app/query/loading.tsx
    src/app/query/components/query-input.tsx
    src/app/query/components/canned-queries.tsx
    src/app/query/components/query-results.tsx
    src/app/query/components/metrics-catalog.tsx
  </files>
  <action>
    **1. Create `src/app/query/loading.tsx`:**
    - Export default Loading component with Tailwind animate-pulse skeletons
    - Skeleton for search bar, canned query cards, and results area
    - Match pattern from src/app/dashboard/loading.tsx

    **2. Create `src/app/query/page.tsx`:**
    - Server Component (no 'use client')
    - Import CANNED_QUERIES from `@/lib/intelligence/nlq/canned-queries`
    - Import METRIC_DEFINITIONS from `@/lib/semantic/schema/financial`
    - Pass both as props to client components
    - Layout: Full-width page with two-column layout on large screens
      - Left column (2/3): QueryInput + QueryResults (stacked)
      - Right column (1/3): CannedQueries + MetricsCatalog (stacked, collapsible sections)
    - On mobile: single column, canned queries first then input
    - Page title: "Ask a Question" with subtitle "Query your business data using natural language"

    **3. Create `src/app/query/components/query-input.tsx`:**
    - 'use client' component
    - Props: `{ onSubmit: (query: string) => void, isLoading: boolean }`
    - Text input with placeholder "Ask anything about your business data..."
    - Submit button with search icon, disabled when isLoading
    - Handle Enter key to submit (but not Shift+Enter for multiline)
    - Clear button (X icon) to reset input
    - When isLoading: input disabled, button shows "Thinking..." text
    - aria-label on input: "Natural language query input"
    - Min 3 chars to submit (match Zod schema)

    **4. Create `src/app/query/components/canned-queries.tsx`:**
    - 'use client' component
    - Props: `{ queries: CannedQuery[], onQuerySelect: (query: CannedQuery, filters?: QueryFilters) => void }`
    - Group queries by category with category headers (capitalized, uppercase, text-sm, text-slate-500)
    - Each query: clickable card/button with query label text
    - If query has requiredFilters: show small "(requires filters)" badge
    - When clicked AND has requiredFilters: show inline filter selection
      - BU filter: dropdown with Cloudsense, Kandy, STL options
      - After filter selected: call onQuerySelect with query + filters
    - When clicked AND no requiredFilters: call onQuerySelect immediately
    - Category order: performance, customers, financials, comparisons
    - Style: rounded border cards, hover:border-blue-500 hover:bg-blue-50 transition

    **5. Create `src/app/query/components/query-results.tsx`:**
    - 'use client' component
    - Props: `{ result: QueryResult | null, onClarificationSelect: (option: string) => void, onFollowUp: (question: string) => void }`
    - **Normal answer display (needsClarification=false):**
      - Answer text in a card with white background
      - Data points: key-value list, numbers formatted with currency/percentage as appropriate
      - Sources: list of data source names
      - Confidence badge: HIGH (green), MEDIUM (yellow), LOW (red) with icon + text
      - Suggested follow-ups: clickable buttons that call onFollowUp
    - **Clarification display (needsClarification=true):**
      - Show interpretation: "I think you're asking about: {interpretation}"
      - Show clarification question text
      - Show 2-3 option buttons, each calls onClarificationSelect(option)
      - Style: yellow/amber background for clarification card to distinguish from answers
    - **Empty state (result=null):**
      - Show "Select a common question or type your own to get started"
      - Light gray text, centered
    - ACCESSIBILITY: confidence badges use color + icon + text

    **6. Create `src/app/query/components/metrics-catalog.tsx`:**
    - 'use client' component
    - Props: `{ metrics: Record<string, MetricDefinition> }`
    - Collapsible section (starts collapsed with "Browse Metrics Catalog" header + chevron)
    - When expanded: searchable list of all metrics from METRIC_DEFINITIONS
    - Search input with debounce (300ms) filtering by name and description
    - Each metric card shows:
      - Display name (bold)
      - Description (text-sm, text-gray-600)
      - Formula (monospace, text-xs)
      - Source (text-xs, text-gray-500)
      - Unit badge (currency/percentage/count)
    - Clicking a metric could copy its name or insert it into query (bonus - at minimum, display info)

    **7. Wire everything together in page.tsx:**
    - The page.tsx Server Component renders client wrapper component
    - Create a thin client wrapper `src/app/query/components/query-page-client.tsx` ('use client') that:
      - Manages state: currentResult (QueryResult | null), isLoading, conversationHistory (string[])
      - Handles canned query selection -> expand template -> call API -> set result
      - Handles free-form query submit -> call API -> set result
      - Handles clarification selection -> append to query -> call API again
      - Handles follow-up click -> set as new query -> call API
      - Passes appropriate props to QueryInput, CannedQueries, QueryResults, MetricsCatalog
  </action>
  <verify>
    Run `npx tsc --noEmit` - all new components compile without errors.
    Run `npm run build` to verify Next.js can build the query route.
    Verify page.tsx renders without errors when data sources are available.
  </verify>
  <done>
    User navigates to /query, sees canned query library grouped by category on right side, free-form input on left. Clicking canned query (no filters) immediately shows answer. Canned query with filters shows filter dropdown first. Free-form query returns answer or clarification dialog. Clarification shows options to refine. Metrics catalog is browseable and searchable. Follow-up questions are clickable.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. Navigate to /query - page loads with two-column layout
4. Click "What is the ARR for each business unit?" canned query - answer displays (or mock if no API key)
5. Click "Why are we missing our margin target?" - filter dropdown appears for BU selection
6. Type "What's the margin?" in free-form input - clarification dialog appears with options
7. Select a clarification option - refined answer displays
8. Click a suggested follow-up question - new query executes
9. Expand metrics catalog - see all 7 metrics with definitions and formulas
10. Search metrics catalog - filters in real-time
</verification>

<success_criteria>
- 7 canned queries across 4 categories selectable and executable
- Free-form query input with 3-500 char validation
- Clarification dialog appears for ambiguous queries with 2-3 options
- Answer display shows interpretation, data points, sources, confidence, and follow-ups
- Metrics catalog browseable and searchable from METRIC_DEFINITIONS
- Claude integration via existing orchestrator with graceful fallback
- WCAG 2.2 AA compliant: confidence badges use color + icon + text
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence-features/03-02-SUMMARY.md`
</output>
